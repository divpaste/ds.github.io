<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Linked List Visualizer</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Reddit+Mono:wght@200..900&display=swap');

    * {
      margin: 0;
      box-sizing: border-box;
      user-select: none;
    }

    body {
      height: 100vh;
      display: flex;
      font-family: 'Reddit Mono', monospace;
      background: #1b1b2f;
      color: #eaeaea;
      overflow: hidden;
    }

    #left {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #ll-area {
      width: 100%;
      flex: 1;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .node rect {
      stroke: white;
      stroke-width: 2;
      rx: 10;
      ry: 10;
    }

    .node text {
      fill: black;
      font-size: 15px;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .link {
      fill: none;
      stroke: white;
      stroke-width: 1.5px;
      marker-end: url(#arrow);
    }

    /* Container for the floating buttons */
    #floating-buttons-wrapper {
      position: fixed;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%) translateY(10px);
      z-index: 50;
      transition: transform 0.1s ease;
    }

    /* Class to move the buttons out of the way */
    #floating-buttons-wrapper.pushed-up {
      transform: translateX(-50%) translateY(-210px);
      /* Adjust this value */
    }

    /* The flex container for the buttons themselves */
    #floating-controls {
      display: flex;
      gap: 12px;
    }

    .floating-btn {
      background: rgba(42, 42, 61, 0);
      color: #eaeaea;
      font-family: 'Reddit Mono', monospace;
      padding: 10px;
      margin: 0 20px;
      font-size: 15px;
      font-weight: 600;
      border-radius: 20px;
      cursor: pointer;
      transition: color 0.1s ease, transform 0.1s ease;
      backdrop-filter: blur(6px);
    }

    .floating-btn:hover {
      color: rgba(86, 86, 120);
    }

    #controls-wrapper {
      position: absolute;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%) translateY(0);
      transition: transform 0.1s ease;
      z-index: 10;
    }

    #controls-wrapper.hidden {
      transform: translateX(-50%) translateY(100%);
    }

    /* Controls panel */
    #controls-panel {
      background: #2a2a3d;
      border: 2px solid #121212;
      padding: 15px 20px;
      border-radius: 15px 15px 0 0;
      border-bottom: none;
      display: grid;
      grid-template-columns: auto auto auto;
      gap: 12px;
      font-family: 'Reddit Mono', monospace;
      justify-content: center;
    }

    #controls-panel fieldset {
      border: 2px solid #121212;
      border-radius: 10px;
      padding: 12px;
      min-width: 170px;
    }

    #controls-panel fieldset div {
      display: flex;
      justify-content: space-between;
    }

    #controls-panel legend {
      text-align: center;
      color: #121212;
      font-weight: bold;
    }

    #controls-panel input {
      text-align: center;
      width: 100%;
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 8px;
      border: none;
      background: #1c1c28;
      color: grey;
      font-size: 14px;
      font-family: Monospace;
    }

    #controls-panel button {
      font-family: 'Reddit Mono', monospace;
      font-weight: 600;
      background: #3b3b55;
      color: #f5f5f5;
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
      margin: 3px;
      width: calc(50% - 6px);
    }

    #controls-panel button:hover {
      background: #565678;
    }

    #controls-panel button:active {
      background: #3b3b55;
      color: #f5f5f5;
    }

    #controls-panel fieldset>button,
    #Misc button {
      width: calc(100% - 6px) !important;
    }

    #Misc {
      display: flex;
      justify-content: center;
      flex-direction: column;
      gap: 8px;
    }

    #Misc input {
      width: 100%;
      margin: 0px;
    }

    #clear-canvas {
      background-color: #b22222;
      color: #fff;
    }

    #clear-canvas:hover {
      background-color: #8b1a1a;
    }

    #node-count-feed {
      position: fixed;
      bottom: 15px;
      right: 20px;
      font-size: 15px;
      font-weight: 600;
      font-family: 'Reddit Mono', monospace;
      color: #eaeaea;
      pointer-events: none;
      background: transparent;
      display: none;
    }

    .node.highlight rect.data-cell {
      fill: rgb(255, 255, 143);
    }

    .node.highlight text.data-text {
      fill: black;
      font-weight: bold;
    }

    #status-feed {
      position: fixed;
      bottom: 15px;
      /* stick to bottom */
      left: 20px;
      /* stick to left */
      width: auto;
      overflow: hidden;
      border-radius: 10px;
      padding: 8px;
      font-size: 15px;
      font-weight: 600;
      line-height: 1.4;
      font-family: 'Reddit Mono', monospace;
      color: #eaeaea;
      pointer-events: none;
    }

    .status-msg {
      opacity: 1;
      transition: opacity 0.4s ease;
    }

    .status-msg.fade-out {
      opacity: 0;
    }


    .status-error {
      color: #ff4d4d;
      /* softer red, readable on dark bg */
    }

    .status-info {
      color: #ffffff;
      /* medium blue */
    }

    .status-success {
      color: #4dff88;
      /* teal-green */
    }
  </style>

<body>
  <div id="left">
    <div id="ll-area">
      <svg>
        <defs>
          <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
            <rect width="40" height="40" fill="#1b1b2f" />
            <path d="M40 0 H0 V40" fill="none" stroke="#333" stroke-width="1" />
          </pattern>
        </defs>
        <rect width="100%" height="100%" fill="url(#grid)" />
      </svg>
    </div>
    <div id="floating-buttons-wrapper">
      <div id="floating-controls">
        <button id="toggle-controls" class="floating-btn" style="border:none">â†‘ Show Controls</button>
      </div>
    </div>

    <div id="controls-wrapper" class="hidden">
      <div id="controls-panel">
        <div id="Insert">
          <fieldset>
            <legend>Insert</legend>
            <input type="text" id="nodeInput" placeholder="Enter value" autocomplete="off">
            <div>
              <button type="button" id="insertStartBtn">Start</button>
              <button type="button" id="addBtn">End</button>
            </div>
            <div>
              <button type="button" id="insertBefore">Before</button>
              <button type="button" id="insertAfter">After</button>
            </div>
            <button type="button" id="insertAt">As n<sup>th</sup> Node</button>
          </fieldset>
        </div>

        <div id="Delete">
          <fieldset>
            <legend>Delete</legend>
            <div><input type="text" placeholder="Enter value" autocomplete="off"></div>
            <div>
              <button type="button" id="deleteStartBtn">Start</button>
              <button type="button" id="deleteEndBtn">End</button>
            </div>
            <div>
              <button type="button" id="deleteBeforeBtn">Before</button>
              <button type="button" id="deleteAfterBtn">After</button>
            </div>
            <button type="button" id="deleteAtBtn">n<sup>th</sup> Node</button>
          </fieldset>
        </div>

        <div id="Misc">
          <div><button style="color: #ff4d4d" id="clear-canvas">Clear Canvas</button></div>
          <div><button type="button" id="makeCircularBtn">Circular</button></div>
          <fieldset>
            <legend>Search</legend>
            <div><input type="text" placeholder="Enter value" autocomplete="off" id="searchInput"></div>
            <div><button type="button" id="searchBtn">Search</button></div>
          </fieldset>
        </div>
      </div>
    </div>
    <div id="status-feed"></div>
    <div id="node-count-feed">Count: <span id="nodeCount">0</span></div>
  </div>
  <script>
    document.addEventListener('DOMContentLoaded', () => {

      /* ==== D3 CODE ==== */
      const svg = d3.select("svg");
      const g = svg.append("g");

      svg.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 5)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "yellowgreen");

      let nodes = [];
      let links = [];

      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(150))
        .force("charge", d3.forceManyBody().strength(-500))
        .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));

      function updateGraph() {
        let linkSel = g.selectAll(".link").data(links);
        let nodeSel = g.selectAll(".node").data(nodes, d => d.id);

        linkSel.exit().remove();
        nodeSel.exit().remove();

        const nodeEnter = nodeSel.enter()
          .append("g")
          .attr("class", "node")
          .call(
            d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended)
          );

        nodeEnter.append("rect")
          .attr("class", "outer")
          .attr("rx", 15).attr("ry", 15)
          .attr("stroke-width", 2)
          .attr("fill", "none")
          .attr("width", d => Math.max(60, d.text.length * 8) + 20)
          .attr("height", 80);

        nodeEnter.append("rect")
          .attr("class", "data-cell")
          .attr("x", 10)
          .attr("y", 10)
          .attr("height", 30)
          .attr("rx", 5).attr("ry", 5)
          .attr("fill", "white")
          .attr("width", d => Math.max(60, d.text.length * 8));

        nodeEnter.append("text")
          .attr("class", "data-text")
          .attr("y", 25)
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "middle")
          .attr("fill", "red")
          .attr("x", d => 10 + Math.max(60, d.text.length * 8) / 2)
          .text(d => d.text);

        const gap = 30;

        nodeEnter.append("circle")
          .attr("cy", 58)
          .attr("r", 5)
          .attr("fill", "#ff4d4d")
          .attr("cx", d => 10 + Math.max(60, d.text.length * 8) / 2 + gap / 2);

        nodeSel = nodeEnter.merge(nodeSel);

        linkSel = linkSel.enter()
          .append("line")
          .attr("class", "link")
          .attr("stroke", "black")
          .attr("stroke-width", 2)
          .attr("marker-end", "url(#arrow)")
          .merge(linkSel);

        simulation.nodes(nodes).on("tick", ticked);
        simulation.force("link").links(links);
        simulation.alpha(1).restart();

        function ticked() {
          const gap = 30;
          const circleY = 58;
          const circleX = d => 10 + Math.max(60, d.text.length * 8) / 2;

          g.selectAll(".link")
            .attr("x1", d => d.source.x + circleX(d.source) + gap / 2)
            .attr("y1", d => d.source.y + circleY)
            .attr("x2", d => d.target.x + circleX(d.target) - gap / 2)
            .attr("y2", d => d.target.y + circleY);

          g.selectAll(".node")
            .attr("transform", d => `translate(${d.x},${d.y})`);

          g.selectAll(".start-pointer").remove();
          g.selectAll(".end-pointer").remove();

          if (nodes.length > 0) {
            const startNode = nodes[0];
            const endNode = nodes[nodes.length - 1];

            const leftCircleX = circleX(startNode) - gap / 2;
            const rightCircleX = circleX(endNode) - gap / 2;

            g.append("line")
              .attr("class", "start-pointer")
              .attr("x1", startNode.x + leftCircleX)
              .attr("y1", startNode.y + circleY + 50)
              .attr("x2", startNode.x + leftCircleX)
              .attr("y2", startNode.y + circleY)
              .attr("stroke", "#eaeaea")
              .attr("stroke-width", 2)
              .attr("marker-end", "url(#arrow)");

            g.append("text")
              .attr("class", "start-pointer")
              .attr("x", startNode.x + leftCircleX)
              .attr("y", startNode.y + circleY + 60)
              .attr("fill", "#eaeaea")
              .attr("text-anchor", "middle")
              .text("Start");

            g.append("line")
              .attr("class", "end-pointer")
              .attr("x1", endNode.x + rightCircleX)
              .attr("y1", endNode.y + circleY + 50)
              .attr("x2", endNode.x + rightCircleX)
              .attr("y2", endNode.y + circleY)
              .attr("stroke", "#eaeaea")
              .attr("stroke-width", 2)
              .attr("marker-end", "url(#arrow)");

            g.append("text")
              .attr("class", "end-pointer")
              .attr("x", endNode.x + rightCircleX)
              .attr("y", endNode.y + circleY + 60)
              .attr("fill", "#eaeaea")
              .attr("text-anchor", "middle")
              .text("End");
          }
        }
      }

      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      const zoom = d3.zoom().scaleExtent([0.3, 3]).on("zoom", (event) => {
        g.attr("transform", event.transform);
      });
      svg.call(zoom);

      let nextId = 0;
      const input = document.getElementById("nodeInput");
      const addStartBtn = document.getElementById("insertStartBtn");
      const addBtn = document.getElementById("addBtn");
      const insertBeforeBtn = document.getElementById("insertBefore");
      const insertAfterBtn = document.getElementById("insertAfter");
      const insertAtBtn = document.getElementById("insertAt");

      // Get the search input and button elements
      const searchInput = document.getElementById("searchInput");
      const searchBtn = document.getElementById("searchBtn");

      // Define the search function
      const performSearch = () => {
        const value = searchInput.value.trim();
        if (!value) {
          logStatus("Cannot search for an empty value", "error");
          return;
        }

        g.selectAll(".node").classed("highlight", false);
        g.selectAll(".highlight-marker").remove();

        const matchingNodes = nodes.filter(n => n.text === value);

        if (matchingNodes.length > 0) {
          matchingNodes.forEach(node => {
            g.selectAll(".node")
              .filter(d => d.id === node.id)
              .classed("highlight", true);

            const index = nodes.indexOf(node);
            const dataCellWidth = Math.max(60, node.text.length * 8);
            const circleX = 10 + dataCellWidth + 15;

            g.append("text")
              .attr("class", "highlight-marker")
              .attr("x", node.x + circleX)
              .attr("y", node.y - 10)
              .attr("text-anchor", "middle")
              .attr("fill", "rgb(255, 255, 143)")
              .attr("font-weight", "bold")
              .style("opacity", 1)
              .text(`Index: ${index + 1}`)
              .transition()
              .duration(2000)
              .remove();
          });

          // Flash the matched nodes (rect/circle) instead of just fading out
          g.selectAll(".node.highlight").select("rect, circle")
            .transition()
            .duration(400)
            .style("opacity", 0.3)
            .transition()
            .duration(400)
            .style("opacity", 1)
            .transition()
            .duration(400)
            .style("opacity", 0.3)
            .transition()
            .duration(400)
            .style("opacity", 1)
            .on("end", function () {
              d3.select(this.parentNode).classed("highlight", false);
            });

          logStatus(
            `Found ${matchingNodes.length} ${matchingNodes.length === 1 ? "instance" : "instances"} of "${value}"`,
            "success"
          );
        } else {
          logStatus(`"${value}" not present`, "error");
        }

        searchInput.value = "";
      };


      // Event listener for the search button click
      searchBtn.addEventListener("click", performSearch);

      // Event listener for pressing Enter in the search input field
      searchInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          event.preventDefault(); // Prevents a potential form submission or other default behavior
          performSearch();
        }
      });

      function updateNodePositions() {
        const startX = window.innerWidth / 3;
        const y = window.innerHeight / 2;
        const gap = 150;
        nodes.forEach((d, i) => {
          d.x = startX + i * gap;
          d.y = y;
        });
      }

      function addNodeEnd() {
        const data = input.value.trim();
        if (!data) {
          logStatus("Cannot add empty node", "error");
          return;
        }
        const newNode = { id: nextId++, text: data };
        nodes.push(newNode);
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }

        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        }
        logStatus(`Node "${data}" added at the end`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
        input.value = "";
      }

      function insertNodeStart() {
        const data = input.value.trim();
        if (!data) {
          logStatus("Cannot add empty node", "error");
          return;
        }

        const newNode = { id: nextId++, text: data };
        nodes.unshift(newNode);
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }

        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        }
        logStatus(`Node "${data}" added at the start`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
        input.value = "";
      }

      function insertBeforeNode() {
        const key = prompt("Enter the value of the node before which to insert:");
        if (!key) return;

        const index = nodes.findIndex(n => n.text === key);
        if (index === -1) {
          logStatus("Key not found", "error");
          return;
        }

        const data = input.value.trim();
        if (!data) {
          logStatus("Cannot add empty node", "error");
          return;
        }

        const newNode = { id: nextId++, text: data };
        nodes.splice(index, 0, newNode);
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }

        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        }
        logStatus(`Node "${data}" added before "${key}"`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
        input.value = "";
      }

      function insertAfterNode() {
        const key = prompt("Enter the value of the node after which to insert:");
        if (!key) return;

        const index = nodes.findIndex(n => n.text === key);
        if (index === -1) {
          logStatus("Key not found", "error");
          return;
        }

        const data = input.value.trim();
        if (!data) {
          logStatus("Cannot add empty node", "error");
          return;
        }

        const newNode = { id: nextId++, text: data };
        nodes.splice(index + 1, 0, newNode);
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }

        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        }
        logStatus(`Node "${data}" added after "${key}"`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
        input.value = "";
      }

      function insertAt() {
        const data = input.value.trim();
        if (!data) {
          logStatus("Cannot add empty node", "error");
          return;
        }

        const pos = parseInt(prompt(`Enter the index (1 to ${nodes.length + 1}):`), 10);

        if (isNaN(pos) || pos < 1 || pos > nodes.length + 1) {
          logStatus(`Invalid index. Current list size: ${nodes.length}`, "error");
          return;
        }

        const newNode = { id: nextId++, text: data };
        nodes.splice(pos - 1, 0, newNode);
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }

        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        }
        logStatus(`Node "${data}" added at index ${pos}`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
        input.value = "";
      }

      function deleteNodeStart() {
        if (nodes.length === 0) {
          logStatus("List is empty", "error");
          return;
        }
        const deletedNode = nodes.shift();
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }
        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        }
        logStatus(`Node "${deletedNode.text}" deleted from the start`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
      }

      function deleteNodeEnd() {
        if (nodes.length === 0) {
          logStatus("List is empty", "error");
          return;
        }
        const deletedNode = nodes.pop();
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }
        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        }
        logStatus(`Node "${deletedNode.text}" deleted from the end`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
      }

      function deleteBeforeNode() {
        const key = prompt("Enter the value of the node before which to delete:");
        if (!key) return;
        const index = nodes.findIndex(n => n.text === key);
        if (index === -1) {
          logStatus("Key not found", "error");
          return;
        }
        if (index === 0) {
          logStatus("No node before the first node", "error");
          return;
        }
        const deletedNode = nodes.splice(index - 1, 1)[0];
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }
        if (isCircular && nodes.length > 1) links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        logStatus(`Node "${deletedNode.text}" deleted before "${key}"`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
      }

      function deleteAfterNode() {
        const key = prompt("Enter the value of the node after which to delete:");
        if (!key) return;
        const index = nodes.findIndex(n => n.text === key);
        if (index === -1) {
          logStatus("Key not found", "error");
          return;
        }
        if (index === nodes.length - 1) {
          logStatus("No node after the last node", "error");
          return;
        }
        const deletedNode = nodes.splice(index + 1, 1)[0];
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }
        if (isCircular && nodes.length > 1) links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        logStatus(`Node "${deletedNode.text}" deleted after "${key}"`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
      }

      function deleteAt() {
        if (nodes.length === 0) {
          logStatus("List is empty", "error");
          return;
        }
        const pos = parseInt(prompt(`Enter the index to delete (1 to ${nodes.length}):`), 10);
        if (isNaN(pos) || pos < 1 || pos > nodes.length) {
          logStatus(`Invalid index. Current list size: ${nodes.length}`, "error");
          return;
        }
        const deletedNode = nodes.splice(pos - 1, 1)[0];
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }
        if (isCircular && nodes.length > 1) links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
        logStatus(`Node "${deletedNode.text}" deleted from index ${pos}`, "success");
        updateNodePositions();
        updateGraph();
        updateNodeCount();
      }

      addStartBtn.addEventListener("click", insertNodeStart);
      addBtn.addEventListener("click", addNodeEnd);
      insertBeforeBtn.addEventListener("click", insertBeforeNode);
      insertAfterBtn.addEventListener("click", insertAfterNode);
      insertAtBtn.addEventListener("click", insertAt);
      deleteStartBtn.addEventListener("click", deleteNodeStart);
      deleteEndBtn.addEventListener("click", deleteNodeEnd);
      deleteBeforeBtn.addEventListener("click", deleteBeforeNode);
      deleteAfterBtn.addEventListener("click", deleteAfterNode);
      deleteAtBtn.addEventListener("click", deleteAt);

      input.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          addNodeEnd();
        }
      });

      const toggleCircularBtn = document.getElementById("makeCircularBtn");
      let isCircular = false;

      toggleCircularBtn.addEventListener("click", () => {
        isCircular = !isCircular;
        toggleCircularBtn.textContent = isCircular ? "Make Linear" : "Make Circular";
        links = [];
        for (let i = 0; i < nodes.length - 1; i++) {
          links.push({ source: nodes[i], target: nodes[i + 1] });
        }
        if (isCircular && nodes.length > 1) {
          links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
          logStatus("List: Circular", "info");
        } else {
          logStatus("List: Linear", "info");
        }
        updateGraph();
      });


      const toggleControlsBtn = document.getElementById("toggle-controls");
      const clearCanvasBtn = document.getElementById("clear-canvas");
      const controlsWrapper = document.getElementById("controls-wrapper");
      const floatingButtonsWrapper = document.getElementById("floating-buttons-wrapper");

      toggleControlsBtn.addEventListener("click", () => {
        const isPanelHidden = controlsWrapper.classList.toggle("hidden");
        toggleControlsBtn.textContent = isPanelHidden ? "â†‘ Show Controls" : "â†“ Hide Controls";
        floatingButtonsWrapper.classList.toggle("pushed-up", !isPanelHidden);
      });

      clearCanvasBtn.addEventListener("click", () => {
        nodes = [];
        links = [];
        nextId = 0;
        g.selectAll("*").remove();
        simulation.nodes(nodes);
        simulation.force("link").links(links);
        updateNodeCount();
        simulation.alpha(1).restart();
        document.getElementById("nodeCount").textContent = 0;
        logStatus("Canvas cleared", "info");
      });

      function logStatus(msg, type = "info", timeout = 4000) {
        const feed = document.getElementById("status-feed");
        const entry = document.createElement("div");
        entry.classList.add("status-msg");
        if (type === "error") entry.classList.add("status-error");
        if (type === "success") entry.classList.add("status-success");
        if (type === "info") entry.classList.add("status-info");
        entry.textContent = `${msg}`;

        feed.appendChild(entry);
        feed.scrollTop = feed.scrollHeight; // auto scroll

        // fade then remove
        setTimeout(() => {
          entry.classList.add("fade-out");
          setTimeout(() => entry.remove(), 500); // match CSS transition
        }, timeout);
      }
      logStatus("Welcome! Use the controls to manipulate a linked list.", "info", 6000);

      // Handle double middle click to fit all nodes in view
      svg.on("mousedown", (event) => {
        if (event.button === 1 && event.detail === 2) { // middle button double click
          event.preventDefault();

          if (nodes.length === 0) return;

          // compute bounding box of all nodes
          const minX = d3.min(nodes, d => d.x);
          const maxX = d3.max(nodes, d => d.x + Math.max(60, d.text.length * 8) + 20);
          const minY = d3.min(nodes, d => d.y);
          const maxY = d3.max(nodes, d => d.y + 80);

          const bounds = [[minX, minY], [maxX, maxY]];
          const width = bounds[1][0] - bounds[0][0];
          const height = bounds[1][1] - bounds[0][1];

          const svgWidth = svg.node().clientWidth;
          const svgHeight = svg.node().clientHeight;

          const scale = Math.min(
            svgWidth / (width + 100),
            svgHeight / (height + 100),
            3 // respect max zoom
          );

          const translateX = (svgWidth - scale * (bounds[0][0] + bounds[1][0])) / 2;
          const translateY = (svgHeight - scale * (bounds[0][1] + bounds[1][1])) / 2;

          const t = d3.zoomIdentity.translate(translateX, translateY).scale(scale);

          svg.transition()
            .duration(750)
            .call(zoom.transform, t);
        }
      });

      function updateNodeCount() {
        const countFeed = document.getElementById("node-count-feed");
        const countSpan = document.getElementById("nodeCount");
        if (nodes.length === 0) {
          countFeed.style.display = "none";
        } else {
          countFeed.style.display = "block";
          countSpan.textContent = nodes.length;
        }
      }


    });
  </script>
</body>

</html>