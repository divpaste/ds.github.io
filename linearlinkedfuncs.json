{
    "L-Insert-Start":"void insertNodeStart(int data) {\n\tstruct node* ptr;\n\tptr = (struct node*) malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed\\n\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (start == NULL) {\n\t\tstart = last = ptr;\n\t} else {\n\t\tptr->next = start;\n\t\tstart = ptr;\n\t}\n}",

    "L-Insert-End": "void insertNodeEnd(int data) {\n\tstruct node *ptr;\n\tptr = (struct node*) malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed\\n\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (start == NULL) {\n\t\tstart = last = ptr;\n\t} else {\n\t\tlast->next = ptr;\n\t\tlast = ptr;\n\t}\n}",
    
    "L-Insert-Before": "void insertBeforeNode(int data, int key) {\n\tstruct node *ptr, *temp = start;\n\tkey = search(key);\n\tif (key == -1 || key == -2) {\n\t\tprintf(\"\\nOperation cannot be performed\");\n\t\treturn;\n\t}\n\tptr = (struct node*) malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed\\n\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (key == 0) {\n\t\tptr->next = start;\n\t\tstart = ptr;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < key - 1; i++) {\n\t\ttemp = temp->next;\n\t}\n\tptr->next = temp->next;\n\ttemp->next = ptr;\n}",
    
    "L-Insert-After": "void insertAfterNode(int data, int key) {\n\tstruct node *ptr, *temp = start;\n\tkey = search(key);\n\tif (key == -1 || key == -2) {\n\t\tprintf(\"\\nOperation cannot be performed\");\n\t\treturn;\n\t}\n\tptr = (struct node*) malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed\\n\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (key == count() - 1) {\n\t\tlast->next = ptr;\n\t\tlast = ptr;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < key; i++) {\n\t\ttemp = temp->next;\n\t}\n\tptr->next = temp->next;\n\ttemp->next = ptr;\n}",
    
    "L-Insert-At": "void insertAt(int data, int key) {\n\tstruct node *ptr, *temp = start;\n\tif (key < 1 || key > (count() + 1)) {\n\t\tprintf(\"Enter Position in Range: (1 - %d)\", count() + 1);\n\t\treturn;\n\t}\n\tptr = (struct node*) malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed\\n\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (start == NULL && key == 1) {\n\t\tstart = last = ptr;\n\t\treturn;\n\t}\n\tif (key == 1) {\n\t\tptr->next = start;\n\t\tstart = ptr;\n\t\treturn;\n\t}\n\tif (key == count() + 1) {\n\t\tlast->next = ptr;\n\t\tlast = ptr;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < key - 2; i++) {\n\t\ttemp = temp->next;\n\t}\n\tptr->next = temp->next;\n\ttemp->next = ptr;\n}",
    
    "L-Delete-Start": "void deleteNodeStart() {\n\tstruct node *del = start;\n\tif (start == NULL) {\n\t\tprintf(\"List is Empty\\n\");\n\t\treturn;\n\t}\n\tif (start == last) {\n\t\tprintf(\"Deleted value: %d\\n\", del->data);\n\t\tstart = last = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tstart = start->next;\n\tprintf(\"Deleted value: %d\\n\", del->data);\n\tfree(del);\n}",
    
    "L-Delete-End": "void deleteNodeEnd() {\n\tstruct node *del = start, *temp = start;\n\tif (start == NULL) {\n\t\tprintf(\"List is Empty\\n\");\n\t\treturn;\n\t}\n\tif (start->next == NULL) {\n\t\tprintf(\"Deleted value: %d\\n\", del->data);\n\t\tstart = last = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\twhile (temp->next != last) {\n\t\ttemp = temp->next;\n\t}\n\tdel = last;\n\tprintf(\"Deleted value: %d\\n\", del->data);\n\tlast = temp;\n\tlast->next = NULL;\n\tfree(del);\n}",
    
    "L-Delete-Before": "void deleteBeforeNode(int key) {\n\tstruct node *del = start, *temp = start;\n\tkey = search(key);\n\tif (key == -1 || key == -2) {\n\t\tprintf(\"\\nOperation cannot be performed\");\n\t\treturn;\n\t}\n\tif (key == 0) {\n\t\tprintf(\"\\nNo Value present before\");\n\t\treturn;\n\t}\n\tif (key == 1) {\n\t\tstart = start->next;\n\t\tprintf(\"Deleted value: %d\\n\", del->data);\n\t\tfree(del);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < key - 2; i++) {\n\t\ttemp = temp->next;\n\t}\n\tdel = temp->next;\n\ttemp->next = temp->next->next;\n\tprintf(\"Deleted value: %d\\n\", del->data);\n\tfree(del);\n}",
    
    "L-Delete-After": "void deleteAfterNode(int key) {\n\tstruct node *del = start, *temp = start;\n\tkey = search(key);\n\tif (key == -1 || key == -2) {\n\t\tprintf(\"\\nOperation cannot be performed\");\n\t\treturn;\n\t}\n\tif (key == count() - 1) {\n\t\tprintf(\"\\nNo Value present After\");\n\t\treturn;\n\t}\n\tif (key == count() - 2) {\n\t\twhile (temp->next != last) {\n\t\t\ttemp = temp->next;\n\t\t}\n\t\tdel = last;\n\t\tprintf(\"Deleted value: %d\\n\", del->data);\n\t\tlast = temp;\n\t\tlast->next = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < key; i++) {\n\t\ttemp = temp->next;\n\t}\n\tdel = temp->next;\n\ttemp->next = temp->next->next;\n\tprintf(\"Deleted value: %d\\n\", del->data);\n\tfree(del);\n}",
    
    "L-Delete-At": "void deleteAt(int key) {\n\tstruct node *del, *temp = start;\n\tif (key < 1 || key > count()) {\n\t\tprintf(\"Position in Range: (1 - %d)\", count() + 1);\n\t\treturn;\n\t}\n\tif (key == 1) {\n\t\tdel = start;\n\t\tstart = start->next;\n\t\tprintf(\"Deleted value: %d\\n\", del->data);\n\t\tfree(del);\n\t\treturn;\n\t}\n\tif (key == count()) {\n\t\twhile (temp->next != last) {\n\t\t\ttemp = temp->next;\n\t\t}\n\t\tdel = last;\n\t\tprintf(\"Deleted value: %d\\n\", del->data);\n\t\tlast = temp;\n\t\tlast->next = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < key - 2; i++) {\n\t\ttemp = temp->next;\n\t}\n\tdel = temp->next;\n\ttemp->next = temp->next->next;\n\tprintf(\"Deleted value: %d\\n\", del->data);\n\tfree(del);\n}"
}
