<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Linked List Visualizer</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Reddit+Mono:wght@200..900&display=swap');

    * {
      margin: 0;
      box-sizing: border-box;
      overflow: hidden;
      user-select:none;
    }

    body {
      height: 100vh;
      display: flex;
      font-family: 'Reddit Mono', monospace;
      background: #1b1b2f;
      color: #eaeaea;
    }

    #left {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #ll-area {
      width: 100%;
      flex: 1;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .node rect {
      stroke: white;
      stroke-width: 2;
      rx: 10;
      ry: 10;
    }

    .node text {
      fill: black;
      font-size: 15px;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .link {
      fill: none;
      stroke: white;
      stroke-width: 1.5px;
      marker-end: url(#arrow);
    }

    /* Toggle button */
    #controls-toggle {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    #toggle-btn,
#reset-btn {
  font-family: 'Reddit Mono', monospace;
  font-weight: 600;
  background: #3b3b55;
  color: #f5f5f5;
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  font-size: 14px;
  cursor: pointer;
  margin-left: 5px; /* optional spacing */
}

#toggle-btn:hover,
#reset-btn:hover {
  background: #565678;
}
    /* Controls panel */
    #controls-panel {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%) scale(0.8);
      transform-origin: bottom center;
      background: #2a2a3d;
      padding: 10px 15px;
      border-radius: 15px;
      box-shadow: 0px 0px 10px black;
      display: grid;
      grid-template-columns: auto auto auto;
      gap: 15px;
      font-family: 'Reddit Mono', monospace;
      opacity: 0;
      transition: transform 0.35s ease, opacity 0.35s ease;
    }
#controls-panel.show {
  animation: growOut 0.45s ease forwards;
}

#controls-panel.hide {
  animation: shrinkIn 0.45s ease forwards;
}

@keyframes growOut {
  from {
    opacity: 0;
    transform: translateX(-50%) scale(0.5); /* tiny at button */
  }
  to {
    opacity: 1;
    transform: translateX(-50%) scale(1); /* full size */
  }
}

@keyframes shrinkIn {
  from {
    opacity: 1;
    transform: translateX(-50%) scale(1);
  }
  to {
    opacity: 0;
    transform: translateX(-50%) scale(0.5);
  }
}

    #controls-panel fieldset {
      border: 3px solid #121212;
      border-radius: 10px;
      padding: 12px;
      min-width: 170px;
    }

    #controls-panel fieldset div {
      display: flex;
      justify-content: space-between;
    }

    #controls-panel legend {
      text-align: center;
      color: #121212;
      font-weight: bold;
    }

    #controls-panel input {
      text-align: center;
      width: 100%;
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 8px;
      border: none;
      background: #1c1c28;
      color: grey;
      font-size: 14px;
      font-family: Monospace;
    }

    #controls-panel button {
      font-family: 'Reddit Mono', monospace;
      font-weight: 600;
      background: #3b3b55;
      color: #f5f5f5;
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
      margin: 3px;
      width: calc(50% - 6px);
    }

    #controls-panel button:hover {
      background: #565678;
    }

    #controls-panel button:active {
      background: #3b3b55;
      color: #f5f5f5;
    }

    #controls-panel fieldset>button,
    #Misc button {
      width: calc(100% - 6px) !important;
    }

    #Misc {
      display: flex;
      justify-content: center;
      flex-direction: column;
      gap: 8px;
    }

    #Misc input {
      width: 100%;
      margin: 0px;
    }

    #Misc h3 {
      color: #eaeaea;
      font-weight: 600;
    }

    .node.highlight rect.data-cell {
  fill: yellow;
}

.node.highlight text.data-text {
  fill: black;
  font-weight: bold;
}

  </style>
</head>

<body>
  <div id="left">
    <div id="ll-area">
      <svg>
        <defs>
          <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
            <circle cx="10" cy="10" r="1.5" fill="#333" />
          </pattern>
        </defs>
        <rect width="100%" height="100%" fill="url(#grid)" />
      </svg>
    </div>

    <!-- Toggle Button -->
    <div id="controls-toggle">
      <button id="toggle-btn">‚öôÔ∏è Show Controls</button>
      <button id="reset-btn">üîÑ Reset Graph</button>
    </div>

    <!-- Control Panel -->
    <div id="controls-panel">
      <div id="Insert">
        <fieldset>
          <legend>Insert</legend>
          <input type="text" id="nodeInput" placeholder="Enter value" autocomplete="off">
          <div>
            <button type="button" id="insertStartBtn">Start</button>
            <button type="button" id="addBtn">End</button>
          </div>
          <div>
            <button type="button" id="insertBefore">Before</button>
            <button type="button" id="insertAfter">After</button>
          </div>
          <button type="button" id="insertAt">As nth Node</button>
        </fieldset>
      </div>

      <div id="Delete">
        <fieldset>
          <legend>Delete</legend>
          <div><input type="text" placeholder="Enter value" autocomplete="off"></div>
          <div>
            <button type="button">Start</button>
            <button type="button">End</button>
          </div>
          <div>
            <button type="button">Before</button>
            <button type="button">After</button>
          </div>
          <button type="button">As nth Node</button>
        </fieldset>
      </div>

      <div id="Misc">
        <div><button type="button">Render Code</button></div>
        <div><button type="button" id="makeCircularBtn">Make Circular</button></div>
        <input type="text" placeholder="Enter value" autocomplete="off" id="searchInput">
        <div><button type="button" id="searchBtn">Search</button></div>
        <h3>Count: <span id="nodeCount">0</span></h3>
      </div>
    </div>
  </div>

  <script>
    /* Toggle Button Logic */
    const toggleBtn = document.getElementById("toggle-btn");
    const controlsPanel = document.getElementById("controls-panel");

    toggleBtn.addEventListener("click", () => {
      controlsPanel.classList.toggle("show");
      toggleBtn.textContent = controlsPanel.classList.contains("show")
        ? "‚ùå Hide Controls"
        : "‚öôÔ∏è Show Controls";
    });

    /* ==== D3 CODE ==== */
    const svg = d3.select("svg");
    const g = svg.append("g");

    svg.append("defs").append("marker")
      .attr("id", "arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 5)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "yellowgreen");

    let nodes = [];
    let links = [];

    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(150))
      .force("charge", d3.forceManyBody().strength(-500))
      .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));

    function updateGraph() {
      let linkSel = g.selectAll(".link").data(links);
      let nodeSel = g.selectAll(".node").data(nodes, d => d.id);

      linkSel.exit().remove();
      nodeSel.exit().remove();

      const nodeEnter = nodeSel.enter()
        .append("g")
        .attr("class", "node")
        .call(
          d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended)
        );

      nodeEnter.append("rect")
        .attr("class", "outer")
        .attr("rx", 15).attr("ry", 15)
        .attr("stroke-width", 2)
        .attr("fill", "none")
        .attr("width", d => Math.max(60, d.text.length * 8) + 20)
        .attr("height", 80);

      nodeEnter.append("rect")
        .attr("class", "data-cell")
        .attr("x", 10)
        .attr("y", 10)
        .attr("height", 30)
        .attr("rx", 5).attr("ry", 5)
        .attr("fill", "white")
        .attr("width", d => Math.max(60, d.text.length * 8));

      nodeEnter.append("text")
        .attr("class", "data-text")
        .attr("y", 25)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("fill", "red")
        .attr("x", d => 10 + Math.max(60, d.text.length * 8) / 2)
        .text(d => d.text);

      nodeEnter.append("rect")
        .attr("class", "next-cell")
        .attr("x", 10)
        .attr("y", 45)
        .attr("stroke", "white")
        .attr("height", 25)
        .attr("rx", 5).attr("ry", 5)
        .attr("fill", "none")
        .attr("width", d => Math.max(60, d.text.length * 8));

      const gap = 30;

      nodeEnter.append("circle")
        .attr("cy", 58)
        .attr("r", 5)
        .attr("fill", "red")
        .attr("cx", d => 10 + Math.max(60, d.text.length * 8) / 2 + gap / 2);

      nodeSel = nodeEnter.merge(nodeSel);

      linkSel = linkSel.enter()
        .append("line")
        .attr("class", "link")
        .attr("stroke", "black")
        .attr("stroke-width", 2)
        .attr("marker-end", "url(#arrow)")
        .merge(linkSel);

      simulation.nodes(nodes).on("tick", ticked);
      simulation.force("link").links(links);
      simulation.alpha(1).restart();

   function ticked() {
        const gap = 30;
        const circleY = 58;
        const circleX = d => 10 + Math.max(60, d.text.length * 8) / 2;

        g.selectAll(".link")
          .attr("x1", d => d.source.x + circleX(d.source) + gap / 2)  // source right (black)
          .attr("y1", d => d.source.y + circleY)
          .attr("x2", d => d.target.x + circleX(d.target) - gap / 2)  // target left (grey)
          .attr("y2", d => d.target.y + circleY);

        g.selectAll(".node")
          .attr("transform", d => `translate(${d.x},${d.y})`);

        // Clear old start/end pointers
        g.selectAll(".start-pointer").remove();
        g.selectAll(".end-pointer").remove();

        if (nodes.length > 0) {
          const startNode = nodes[0];
          const endNode = nodes[nodes.length - 1];

          // Left circle of node = entry
          const leftCircleX = circleX(startNode) - gap / 2;
          const rightCircleX = circleX(endNode) - gap / 2;

          // START pointer from below into left circle of first node
          g.append("line")
            .attr("class", "start-pointer")
            .attr("x1", startNode.x + leftCircleX)
            .attr("y1", startNode.y + circleY + 50) // below
            .attr("x2", startNode.x + leftCircleX)
            .attr("y2", startNode.y + circleY)
            .attr("stroke", "#eaeaea")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrow)");

          g.append("text")
            .attr("class", "start-pointer")
            .attr("x", startNode.x + leftCircleX)
            .attr("y", startNode.y + circleY + 60)
            .attr("fill", "#eaeaea")
            .attr("text-anchor", "middle")
            .text("Start");

          // END pointer from below into right circle of last node
          g.append("line")
            .attr("class", "end-pointer")
            .attr("x1", endNode.x + rightCircleX)
            .attr("y1", endNode.y + circleY + 50) // below
            .attr("x2", endNode.x + rightCircleX)
            .attr("y2", endNode.y + circleY)
            .attr("stroke", "#eaeaea")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrow)");

          g.append("text")
            .attr("class", "end-pointer")
            .attr("x", endNode.x + rightCircleX)
            .attr("y", endNode.y + circleY + 60)
            .attr("fill", "#eaeaea")
            .attr("text-anchor", "middle")
            .text("End");
        }
      }
      
document.getElementById("nodeCount").textContent = nodes.length;
    }

    function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
    function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

    const zoom = d3.zoom().scaleExtent([0.3, 3]).on("zoom", (event) => { g.attr("transform", event.transform); });
    svg.call(zoom);

    let nextId = 0;
    const input = document.getElementById("nodeInput");
    const addStartBtn = document.getElementById("insertStartBtn");
    const addBtn = document.getElementById("addBtn");
    const insertBeforeBtn = document.getElementById("insertBefore");
    const insertAfterBtn = document.getElementById("insertAfter");
    const insertAtBtn = document.getElementById("insertAt");

const searchInput = document.getElementById("searchInput"); // also give the input an id
const searchBtn = document.getElementById("searchBtn");


searchBtn.addEventListener("click", () => {
  const value = searchInput.value.trim();
  if (!value) return;

  // Clear any previous highlights and markers
  g.selectAll(".node").classed("highlight", false);
  g.selectAll(".highlight-marker").remove();

  const index = nodes.findIndex(n => n.text === value);
  const node = nodes.find(n => n.text === value);

  if (node) {
    // Highlight the found node
    g.selectAll(".node")
      .filter(d => d.id === node.id)
      .classed("highlight", true);

    // Add position marker above the node
    const gap = 30;
    const circleY = 58;
    const circleX = 10 + Math.max(60, node.text.length * 8) / 2;

    g.append("text")
      .attr("class", "highlight-marker")
      .attr("x", node.x + circleX)
      .attr("y", node.y - 10)
      .attr("text-anchor", "middle")
      .attr("fill", "yellow")
      .attr("font-weight", "bold")
      .text(`Pos: ${index+1}`);

    // Remove highlight and marker after 3.5 seconds
    setTimeout(() => {
      g.selectAll(".node").classed("highlight", false);
      g.selectAll(".highlight-marker").remove();
    }, 2000);
  } else {
    alert(`Value "${value}" not present in the list`);
  }
  searchInput.value = "";
});

    function addNodeEnd() {
  const data = input.value.trim();
  if (!data) return;

  let newNode;
  if (nodes.length === 0) {
    newNode = {
      id: nextId++,
      text: data,
      x: window.innerWidth / 3,
      y: window.innerHeight / 2
    };
    nodes.push(newNode);
  } else {
    const last = nodes[nodes.length - 1];
    newNode = {
      id: nextId++,
      text: data,
      x: last.x + 150,
      y: last.y
    };

    if (isCircular) {
      // Remove last ‚Üí first circular link
      links = links.filter(l => !(l.source === last && l.target === nodes[0]));
    }

    nodes.push(newNode);
    links.push({ source: last, target: newNode });

    if (isCircular) {
      // Restore circular link
      links.push({ source: newNode, target: nodes[0] });
    }
  }

  updateGraph();
  input.value = "";
}

function insertNodeStart() {
  const data = input.value.trim();
  if (!data) return;

  const newNode = { id: nextId++, text: data, x: 0, y: 0 };

  if (nodes.length === 0) {
    nodes.unshift(newNode);
  } else {
    const first = nodes[0];
    const last = nodes[nodes.length - 1];

    if (isCircular) {
      // Remove old last‚Üífirst circular link
      links = links.filter(l => !(l.source === last && l.target === first));
    }

    // Insert at start
    nodes.unshift(newNode);

    // Add link new‚Üíold first
    links.push({ source: newNode, target: first });
  }

  // Re-add circular link from last‚Üífirst
  if (isCircular && nodes.length > 1) {
    const lastNode = nodes[nodes.length - 1];
    links = links.filter(l => !(l.source === lastNode && l.target === nodes[0]));
    links.push({ source: lastNode, target: nodes[0] });
  }

  updateGraph();
  input.value = "";
}


// Insert Before
// Recalculate horizontal positions
function updateNodePositions() {
  const startX = window.innerWidth / 3;
  const y = window.innerHeight / 2;
  const gap = 150;
  nodes.forEach((d, i) => {
    d.x = startX + i * gap;
    d.y = y;
  });
}

// Add node at end
function addNodeEnd() {
  const data = input.value.trim();
  if (!data) return;

  const newNode = { id: nextId++, text: data };
  nodes.push(newNode);

  // Add link from previous node
  if(nodes.length > 1){
    const prevNode = nodes[nodes.length - 2];
    links.push({ source: prevNode, target: newNode });
  }

  // Handle circular
  if(isCircular && nodes.length > 1){
    links = links.filter(l => !(l.source === nodes[nodes.length-1] && l.target === nodes[0]));
    links.push({ source: nodes[nodes.length-1], target: nodes[0] });
  }

  updateNodePositions();
  updateGraph();
  input.value = "";
}

// Add node at start
function insertNodeStart() {
  const data = input.value.trim();
  if(!data) return;

  const newNode = { id: nextId++, text: data };
  nodes.unshift(newNode);

  // Update links
  links = [];
  for(let i=0; i<nodes.length-1; i++){
    links.push({ source: nodes[i], target: nodes[i+1] });
  }

  // Handle circular
  if(isCircular && nodes.length > 1){
    links.push({ source: nodes[nodes.length-1], target: nodes[0] });
  }

  updateNodePositions();
  updateGraph();
  input.value = "";
}

// Insert before a given node
function insertBeforeNode() {
  const key = prompt("Enter the value of the node before which to insert:");
  if(!key) return;

  const index = nodes.findIndex(n => n.text === key);
  if(index === -1){
    alert("Key not found");
    return;
  }

  const data = input.value.trim();
  if(!data){
    alert("Enter a value in the input field");
    return;
  }

  const newNode = { id: nextId++, text: data };
  nodes.splice(index, 0, newNode);

  // Rebuild links
  links = [];
  for(let i=0; i<nodes.length-1; i++){
    links.push({ source: nodes[i], target: nodes[i+1] });
  }

  if(isCircular && nodes.length > 1){
    links.push({ source: nodes[nodes.length-1], target: nodes[0] });
  }

  updateNodePositions();
  updateGraph();
  input.value = "";
}

// Insert after a given node
function insertAfterNode() {
  const key = prompt("Enter the value of the node after which to insert:");
  if(!key) return;

  const index = nodes.findIndex(n => n.text === key);
  if(index === -1){
    alert("Key not found");
    return;
  }

  const data = input.value.trim();
  if(!data){
    alert("Enter a value in the input field");
    return;
  }

  const newNode = { id: nextId++, text: data };
  nodes.splice(index+1, 0, newNode);

  // Rebuild links
  links = [];
  for(let i=0; i<nodes.length-1; i++){
    links.push({ source: nodes[i], target: nodes[i+1] });
  }

  if(isCircular && nodes.length > 1){
    links.push({ source: nodes[nodes.length-1], target: nodes[0] });
  }

  updateNodePositions();
  updateGraph();
  input.value = "";
}

function insertAt() {
  const data = input.value.trim(); // node value
  if (!data) {
    alert("Enter a value in the input field");
    return;
  }

  const pos = parseInt(prompt(`Enter the position (1 to ${nodes.length + 1}):`), 10);

  if (isNaN(pos) || pos < 1 || pos > nodes.length + 1) {
    alert(`Invalid position. Current list size: ${nodes.length}`);
    return;
  }

  const newNode = { id: nextId++, text: data };

  // Convert 1-based position to 0-based index for splice
  nodes.splice(pos - 1, 0, newNode);

  // Rebuild links
  links = [];
  for (let i = 0; i < nodes.length - 1; i++) {
    links.push({ source: nodes[i], target: nodes[i + 1] });
  }

  if (isCircular && nodes.length > 1) {
    links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
  }

  updateNodePositions();
  updateGraph();

  input.value = "";
}


    addStartBtn.addEventListener("click", insertNodeStart);
    addBtn.addEventListener("click", addNodeEnd);
    insertBeforeBtn.addEventListener("click", insertBeforeNode);
    insertAfterBtn.addEventListener("click", insertAfterNode);
    insertAtBtn.addEventListener("click", insertAt);

    input.addEventListener("keypress", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        addNodeEnd();
      }
    });

    const toggleCircularBtn = document.getElementById("makeCircularBtn");
let isCircular = false;

toggleCircularBtn.addEventListener("click", () => {
  if (!isCircular) {
    // Make it circular
    if (nodes.length > 1) {
      links = links.filter(l => !(l.source === nodes[nodes.length - 1] && l.target === nodes[0]));
      links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
      updateGraph();
      isCircular = true;
      toggleCircularBtn.textContent = "Make Linear";
    }
  } else {
    // Break the circular link
    links = links.filter(l => !(l.source === nodes[nodes.length - 1] && l.target === nodes[0]));
    updateGraph();
    isCircular = false;
    toggleCircularBtn.textContent = "Make Circular";
  }
});

const resetBtn = document.getElementById("reset-btn");

resetBtn.addEventListener("click", () => {
  // Clear nodes and links
  nodes = [];
  links = [];
  nextId = 0;

  // Remove all elements from SVG group
  g.selectAll("*").remove();

  // Reset simulation
  simulation.nodes(nodes);
  simulation.force("link").links(links);
  simulation.alpha(1).restart();

  // Reset node count
  document.getElementById("nodeCount").textContent = 0;
});


  </script>
</body>
</html>