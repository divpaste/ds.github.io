<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Linked List Visualizer</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Reddit+Mono:wght@200..900&display=swap');

    * {
      margin: 0;
      box-sizing: border-box;
      overflow: hidden;
    }

    body {
      height: 100vh;
      display: flex;
      font-family: 'Reddit Mono', monospace;
      background: #1b1b2f;
      color: #eaeaea;
    }

    #left {
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #ll-area {
      width: 100%;
      flex: 1;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .node rect {
      stroke: white;
      stroke-width: 2;
      rx: 10;
      ry: 10;
    }

    .node text {
      fill: black;
      font-size: 15px;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .link {
      fill: none;
      stroke: white;
      stroke-width: 1.5px;
      marker-end: url(#arrow);
    }

    /* Toggle button */
    #controls-toggle {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    #toggle-btn {
      font-family: 'Reddit Mono', monospace;
      font-weight: 600;
      background: #3b3b55;
      color: #f5f5f5;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
    }

    #toggle-btn:hover {
      background: #565678;
    }

    /* Controls panel */
    #controls-panel {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%) scale(0.8);
      transform-origin: bottom center;
      background: #2a2a3d;
      padding: 10px 15px;
      border-radius: 15px;
      box-shadow: 0px 0px 10px black;
      display: grid;
      grid-template-columns: auto auto auto;
      gap: 15px;
      font-family: 'Reddit Mono', monospace;
      opacity: 0;
      transition: transform 0.35s ease, opacity 0.35s ease;
    }
#controls-panel.show {
  animation: growOut 0.45s ease forwards;
}

#controls-panel.hide {
  animation: shrinkIn 0.45s ease forwards;
}

@keyframes growOut {
  from {
    opacity: 0;
    transform: translateX(-50%) scale(0.5); /* tiny at button */
  }
  to {
    opacity: 1;
    transform: translateX(-50%) scale(1); /* full size */
  }
}

@keyframes shrinkIn {
  from {
    opacity: 1;
    transform: translateX(-50%) scale(1);
  }
  to {
    opacity: 0;
    transform: translateX(-50%) scale(0.5);
  }
}

    #controls-panel fieldset {
      border: 3px solid #121212;
      border-radius: 10px;
      padding: 12px;
      min-width: 170px;
    }

    #controls-panel fieldset div {
      display: flex;
      justify-content: space-between;
    }

    #controls-panel legend {
      text-align: center;
      color: #121212;
      font-weight: bold;
    }

    #controls-panel input {
      text-align: center;
      width: 100%;
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 8px;
      border: none;
      background: #1c1c28;
      color: grey;
      font-size: 14px;
      font-family: Monospace;
    }

    #controls-panel button {
      font-family: 'Reddit Mono', monospace;
      font-weight: 600;
      background: #3b3b55;
      color: #f5f5f5;
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
      margin: 3px;
      width: calc(50% - 6px);
    }

    #controls-panel button:hover {
      background: #565678;
    }

    #controls-panel button:active {
      background: #3b3b55;
      color: #f5f5f5;
    }

    #controls-panel fieldset>button,
    #Misc button {
      width: calc(100% - 6px) !important;
    }

    #Misc {
      display: flex;
      justify-content: center;
      flex-direction: column;
      gap: 8px;
    }

    #Misc input {
      width: 100%;
      margin: 0px;
    }

    #Misc h3 {
      color: #eaeaea;
      font-weight: 600;
    }
  </style>
</head>

<body>
  <div id="left">
    <div id="ll-area">
      <svg>
        <defs>
          <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
            <circle cx="10" cy="10" r="1.5" fill="#333" />
          </pattern>
        </defs>
        <rect width="100%" height="100%" fill="url(#grid)" />
      </svg>
    </div>

    <!-- Toggle Button -->
    <div id="controls-toggle">
      <button id="toggle-btn">⚙️ Show Controls</button>
    </div>

    <!-- Control Panel -->
    <div id="controls-panel">
      <div id="Insert">
        <fieldset>
          <legend>Insert</legend>
          <input type="text" id="nodeInput" placeholder="Enter value" autocomplete="off">
          <div>
            <button type="button" id="insertStartBtn">Start</button>
            <button type="button" id="addBtn">End</button>
          </div>
          <div>
            <button type="button">Before</button>
            <button type="button">After</button>
          </div>
          <button type="button">As nth Node</button>
        </fieldset>
      </div>

      <div id="Delete">
        <fieldset>
          <legend>Delete</legend>
          <div><input type="text" placeholder="Enter value" autocomplete="off"></div>
          <div>
            <button type="button">Start</button>
            <button type="button">End</button>
          </div>
          <div>
            <button type="button">Before</button>
            <button type="button">After</button>
          </div>
          <button type="button">As nth Node</button>
        </fieldset>
      </div>

      <div id="Misc">
        <div><button type="button">Render Code</button></div>
        <div><button type="button" id="makeCircularBtn">Make Circular</button></div>
        <input type="text" placeholder="Enter value" autocomplete="off">
        <div><button type="button">Search</button></div>
        <h3>Count: <span id="nodeCount">0</span></h3>
      </div>
    </div>
  </div>

  <script>
    /* Toggle Button Logic */
    const toggleBtn = document.getElementById("toggle-btn");
    const controlsPanel = document.getElementById("controls-panel");

    toggleBtn.addEventListener("click", () => {
      controlsPanel.classList.toggle("show");
      toggleBtn.textContent = controlsPanel.classList.contains("show")
        ? "❌ Hide Controls"
        : "⚙️ Show Controls";
    });

    /* ==== D3 CODE ==== */
    const svg = d3.select("svg");
    const g = svg.append("g");

    svg.append("defs").append("marker")
      .attr("id", "arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 5)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "yellowgreen");

    let nodes = [];
    let links = [];

    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(150))
      .force("charge", d3.forceManyBody().strength(-500))
      .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));

    function updateGraph() {
      let linkSel = g.selectAll(".link").data(links);
      let nodeSel = g.selectAll(".node").data(nodes, d => d.id);

      linkSel.exit().remove();
      nodeSel.exit().remove();

      const nodeEnter = nodeSel.enter()
        .append("g")
        .attr("class", "node")
        .call(
          d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended)
        );

      nodeEnter.append("rect")
        .attr("class", "outer")
        .attr("rx", 15).attr("ry", 15)
        .attr("stroke-width", 2)
        .attr("fill", "none")
        .attr("width", d => Math.max(60, d.text.length * 8) + 20)
        .attr("height", 80);

      nodeEnter.append("rect")
        .attr("class", "data-cell")
        .attr("x", 10)
        .attr("y", 10)
        .attr("height", 30)
        .attr("rx", 5).attr("ry", 5)
        .attr("fill", "white")
        .attr("width", d => Math.max(60, d.text.length * 8));

      nodeEnter.append("text")
        .attr("class", "data-text")
        .attr("y", 25)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("fill", "red")
        .attr("x", d => 10 + Math.max(60, d.text.length * 8) / 2)
        .text(d => d.text);

      nodeEnter.append("rect")
        .attr("class", "next-cell")
        .attr("x", 10)
        .attr("y", 45)
        .attr("stroke", "white")
        .attr("height", 25)
        .attr("rx", 5).attr("ry", 5)
        .attr("fill", "none")
        .attr("width", d => Math.max(60, d.text.length * 8));

      const gap = 30;

      nodeEnter.append("circle")
        .attr("cy", 58)
        .attr("r", 5)
        .attr("fill", "red")
        .attr("cx", d => 10 + Math.max(60, d.text.length * 8) / 2 + gap / 2);

      nodeSel = nodeEnter.merge(nodeSel);

      linkSel = linkSel.enter()
        .append("line")
        .attr("class", "link")
        .attr("stroke", "black")
        .attr("stroke-width", 2)
        .attr("marker-end", "url(#arrow)")
        .merge(linkSel);

      simulation.nodes(nodes).on("tick", ticked);
      simulation.force("link").links(links);
      simulation.alpha(1).restart();

   function ticked() {
        const gap = 30;
        const circleY = 58;
        const circleX = d => 10 + Math.max(60, d.text.length * 8) / 2;

        g.selectAll(".link")
          .attr("x1", d => d.source.x + circleX(d.source) + gap / 2)  // source right (black)
          .attr("y1", d => d.source.y + circleY)
          .attr("x2", d => d.target.x + circleX(d.target) - gap / 2)  // target left (grey)
          .attr("y2", d => d.target.y + circleY);

        g.selectAll(".node")
          .attr("transform", d => `translate(${d.x},${d.y})`);

        // Clear old start/end pointers
        g.selectAll(".start-pointer").remove();
        g.selectAll(".end-pointer").remove();

        if (nodes.length > 0) {
          const startNode = nodes[0];
          const endNode = nodes[nodes.length - 1];

          // Left circle of node = entry
          const leftCircleX = circleX(startNode) - gap / 2;
          const rightCircleX = circleX(endNode) - gap / 2;

          // START pointer from below into left circle of first node
          g.append("line")
            .attr("class", "start-pointer")
            .attr("x1", startNode.x + leftCircleX)
            .attr("y1", startNode.y + circleY + 50) // below
            .attr("x2", startNode.x + leftCircleX)
            .attr("y2", startNode.y + circleY)
            .attr("stroke", "#eaeaea")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrow)");

          g.append("text")
            .attr("class", "start-pointer")
            .attr("x", startNode.x + leftCircleX)
            .attr("y", startNode.y + circleY + 60)
            .attr("fill", "#eaeaea")
            .attr("text-anchor", "middle")
            .text("Start");

          // END pointer from below into right circle of last node
          g.append("line")
            .attr("class", "end-pointer")
            .attr("x1", endNode.x + rightCircleX)
            .attr("y1", endNode.y + circleY + 50) // below
            .attr("x2", endNode.x + rightCircleX)
            .attr("y2", endNode.y + circleY)
            .attr("stroke", "#eaeaea")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrow)");

          g.append("text")
            .attr("class", "end-pointer")
            .attr("x", endNode.x + rightCircleX)
            .attr("y", endNode.y + circleY + 60)
            .attr("fill", "#eaeaea")
            .attr("text-anchor", "middle")
            .text("End");
        }
      }
      
document.getElementById("nodeCount").textContent = nodes.length;
    }

    function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
    function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

    const zoom = d3.zoom().scaleExtent([0.3, 3]).on("zoom", (event) => { g.attr("transform", event.transform); });
    svg.call(zoom);

    let nextId = 0;
    const input = document.getElementById("nodeInput");
    const addStartBtn = document.getElementById("insertStartBtn");
    const addBtn = document.getElementById("addBtn");

    function addNodeEnd() {
  const data = input.value.trim();
  if (!data) return;

  let newNode;
  if (nodes.length === 0) {
    newNode = {
      id: nextId++,
      text: data,
      x: window.innerWidth / 3,
      y: window.innerHeight / 2
    };
    nodes.push(newNode);
  } else {
    const last = nodes[nodes.length - 1];
    newNode = {
      id: nextId++,
      text: data,
      x: last.x + 150,
      y: last.y
    };

    if (isCircular) {
      // Remove last → first circular link
      links = links.filter(l => !(l.source === last && l.target === nodes[0]));
    }

    nodes.push(newNode);
    links.push({ source: last, target: newNode });

    if (isCircular) {
      // Restore circular link
      links.push({ source: newNode, target: nodes[0] });
    }
  }

  updateGraph();
  input.value = "";
}

function insertNodeStart() {
  const data = input.value.trim();
  if (!data) return;

  let newNode;
  if (nodes.length === 0) {
    newNode = {
      id: nextId++,
      text: data,
      x: window.innerWidth / 3,
      y: window.innerHeight / 2
    };
    nodes.unshift(newNode);
  } else {
    const first = nodes[0];
    const last = nodes[nodes.length - 1];
    newNode = {
      id: nextId++,
      text: data,
      x: first.x - 150,
      y: first.y
    };

    if (isCircular) {
      // Remove last → first circular link
      links = links.filter(l => !(l.source === last && l.target === first));
    }

    nodes.unshift(newNode);
    links.push({ source: newNode, target: first });

    if (isCircular) {
      // Restore circular link
      links.push({ source: nodes[nodes.length - 1], target: newNode });
    }
  }

  updateGraph();
  input.value = "";
}

    addStartBtn.addEventListener("click", insertNodeStart);
    addBtn.addEventListener("click", addNodeEnd);

    input.addEventListener("keypress", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        addNodeEnd();
      }
    });

    const toggleCircularBtn = document.getElementById("makeCircularBtn");
let isCircular = false;

toggleCircularBtn.addEventListener("click", () => {
  if (!isCircular) {
    // Make it circular
    if (nodes.length > 1) {
      links = links.filter(l => !(l.source === nodes[nodes.length - 1] && l.target === nodes[0]));
      links.push({ source: nodes[nodes.length - 1], target: nodes[0] });
      updateGraph();
      isCircular = true;
      toggleCircularBtn.textContent = "Unmake Circular";
    }
  } else {
    // Break the circular link
    links = links.filter(l => !(l.source === nodes[nodes.length - 1] && l.target === nodes[0]));
    updateGraph();
    isCircular = false;
    toggleCircularBtn.textContent = "Make Circular";
  }
});

  </script>
</body>
</html>