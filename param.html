<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Linked List Visualizer</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Reddit+Mono:wght@200..900&display=swap');

    * {
      margin: 0;
      box-sizing: border-box;
    }

    body {
      height: 100vh;
      display: grid;
      grid-template-columns: 70% 30%;
      font-family: 'Reddit Mono', monospace;
      background: #1b1b2f;
      color: #eaeaea;
    }

    #left {
      position: relative;
      display: grid;
      grid-template-rows: 1fr 60px;
    }

    #ll-area {
      width: 100%;
      height: 100%;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .node rect {
      fill: white;
      stroke: #ffffff;
      stroke-width: 2;
      rx: 6;
      ry: 6;
    }

    .node text {
      fill: #101010;
      font-size: 14px;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .link {
      fill: none;
      stroke: #cccccc;
      stroke-width: 1.5px;
      marker-end: url(#arrow);
    }

    #controls-panel button {
      background: linear-gradient(145deg, #3a3a7a, #2c2c59);
      color: #f0f0f0;
      border: none;
      border-radius: 10px;
      padding: 8px 14px;
      cursor: pointer;
      font-weight: 600;
      font-family: 'Reddit Mono', monospace;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 -2px 4px rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease-in-out;
    }

    #controls-panel button:hover {
      background: linear-gradient(145deg, #5a5ab0, #414182);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5), inset 0 -2px 4px rgba(255, 255, 255, 0.15);
    }

    #controls-panel button:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) inset;
    }


    #right {
      background: #14142b;
      border-left: 6px solid #0d0d1a;
      display: grid;
      grid-template-rows: 40px auto;
    }

    #heading {
      background: #3f51b5;
      color: white;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-size: 18px;
      font-weight: bold;
      font-family: 'Reddit Mono', monospace;
    }

    #area {
      margin: 5px;
      overflow-y: auto;
    }

    #code-area {
      font-size: 16px;
      font-family: 'Reddit Mono', monospace;
      color: #cfd8dc;
      line-height: 1.4;
    }

    .code-line {
      padding: 2px 8px;
    }

    .code-line.highlight {
      background: #ffee58;
      color: #101010;
    }

    #toggle-code {
      position: fixed;
      top: 10px;
      right: 10px;
      background: linear-gradient(145deg, #3a3a7a, #2c2c59);
      color: #f0f0f0;
      border: none;
      border-radius: 10px;
      padding: 8px 14px;
      cursor: pointer;
      font-weight: 600;
      font-family: 'Reddit Mono', monospace;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4), inset 0 -2px 4px rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease-in-out;
      z-index: 1000;
    }

    #toggle-code:hover {
      background: linear-gradient(145deg, #5a5ab0, #414182);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5), inset 0 -2px 4px rgba(255, 255, 255, 0.15);
    }

    #toggle-code:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3) inset;
    }
  </style>
</head>

<body>
  <button id="toggle-code">Code</button>
  <div id="left">
    <div id="ll-area">
      <svg></svg>
    </div>
    <div id="controls-panel">
      <button id="addBtn">Add Node</button>
      <button id="renderBtn">Render Code</button>
      <button id="up">↑ Up</button>
      <button id="down">↓ Down</button>
      <button id="zoom-in">+</button>
      <button id="zoom-out">-</button>
    </div>
  </div>

  <div id="right">
    <div id="heading">CODE:</div>
    <div id="area">
      <div id="code-area"></div>
    </div>
  </div>

  <script>
    const svg = d3.select("svg");
    const g = svg.append("g");

    svg.append("defs").append("marker")
      .attr("id", "arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 5)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "#cccccc");

    let nodes = [];
    let links = [];

    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(120))
      .force("charge", d3.forceManyBody().strength(-400))
      .force("center", d3.forceCenter(window.innerWidth / 3, window.innerHeight / 2));

    let nodeSel = g.selectAll(".node");
    let linkSel = g.selectAll(".link");

    function updateGraph() {
      linkSel = linkSel.data(links);
      linkSel.exit().remove();
      linkSel = linkSel.enter()
        .append("path")
        .attr("class", "link")
        .attr("fill", "none")
        .attr("stroke", "#999")
        .attr("stroke-width", 2)
        .attr("marker-end", "url(#arrow)")   // only arrow at the end
        .merge(linkSel);

      nodeSel = nodeSel.data(nodes, d => d.id);
      nodeSel.exit().remove();

      const enter = nodeSel.enter().append("g").attr("class", "node")
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

      enter.append("rect")
        .attr("width", d => Math.max(40, d.text.length * 9))
        .attr("height", 30)
        .attr("x", d => -Math.max(40, d.text.length * 9) / 2)
        .attr("y", -15);

      enter.append("text").text(d => d.text);

      nodeSel = enter.merge(nodeSel);

      simulation.nodes(nodes).on("tick", () => {
        linkSel.attr("d", d => {
          const midX = (d.source.x + d.target.x) / 2;
          const midY = (d.source.y + d.target.y) / 2 + 25; // offset below nodes
          return `M${d.source.x},${d.source.y + 25} L${midX},${midY} L${d.target.x},${d.target.y + 25}`;
        });
        nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
      });

      // Inside updateGraph, after simulation tick update:
      simulation.nodes(nodes).on("tick", () => {
        linkSel.attr("d", d => {
          const midX = (d.source.x + d.target.x) / 2;
          const midY = (d.source.y + d.target.y) / 2 + 25;
          return `M${d.source.x},${d.source.y + 25} L${midX},${midY} L${d.target.x},${d.target.y + 25}`;
        });
        nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);

        // Remove old pointers
        g.selectAll(".start-pointer").remove();
        g.selectAll(".end-pointer").remove();

        if (nodes.length > 0) {
          // Start pointer
          const startNode = nodes[0];
          g.append("line")
            .attr("class", "start-pointer")
            .attr("x1", startNode.x)
            .attr("y1", startNode.y + 60)
            .attr("x2", startNode.x)
            .attr("y2", startNode.y + 20)
            .attr("stroke", "#eaeaea")
            .attr("stroke-width", 2.5)
            .attr("marker-end", "url(#arrow)");

          g.append("text")
            .attr("class", "start-pointer")
            .attr("x", startNode.x)
            .attr("y", startNode.y + 70)
            .attr("fill", "#eaeaea")
            .attr("text-anchor", "middle")
            .text("Start");

          // End pointer
          const endNode = nodes[nodes.length - 1];
          g.append("line")
            .attr("class", "end-pointer")
            .attr("x1", endNode.x)
            .attr("y1", endNode.y - 60)
            .attr("x2", endNode.x)
            .attr("y2", endNode.y - 20)
            .attr("stroke", "#eaeaea")
            .attr("stroke-width", 2.5)
            .attr("marker-end", "url(#arrow)");

          g.append("text")
            .attr("class", "end-pointer")
            .attr("x", endNode.x)
            .attr("y", endNode.y - 70)
            .attr("fill", "#eaeaea")
            .attr("text-anchor", "middle")
            .text("End");
        }
      });
      simulation.force("link").links(links);
      simulation.alpha(1).restart();
    }

    function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
    function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

    const zoom = d3.zoom().scaleExtent([0.3, 3]).on("zoom", (event) => { g.attr("transform", event.transform); });
    svg.call(zoom);

    document.getElementById("zoom-in").onclick = () => svg.transition().call(zoom.scaleBy, 1.4);
    document.getElementById("zoom-out").onclick = () => svg.transition().call(zoom.scaleBy, 0.6);

    let nextId = 0;
    document.getElementById("addBtn").addEventListener("click", () => {
      const data = prompt("Enter Int data:");
      if (!data) return;
      const newNode = { id: nextId++, text: data };
      nodes.push(newNode);
      if (nodes.length > 1) links.push({ source: nodes[nodes.length - 2], target: newNode });
      updateGraph();
    });

    function getCode() {
      return `void insertEnd(){
  struct node *ptr,*temp=start;
  ptr=(struct node*)malloc(sizeof(struct node));
  if(ptr==NULL){
    printf("Memory Allocation Failed");
    return;
  }
  printf("Insert Value at End:");
  scanf("%d",&ptr->data);
  if(temp==NULL){
    start=ptr;
    ptr->next=NULL;
  } else {
    while(temp->next!=NULL){
      temp=temp->next;
    }
    temp->next=ptr;
    ptr->next=NULL;
  }
}`.trim().split("\n");
    }

    function renderCode() {
      const area = document.getElementById("code-area");
      area.innerHTML = "";
      const lines = getCode();
      for (let line of lines) {
        const div = document.createElement("div");
        div.textContent = line;
        div.classList.add("code-line");
        area.appendChild(div);
      }
      curr = -1;
    }

    let curr = -1;
    function selectLine() {
      const lines = document.querySelectorAll(".code-line");
      lines.forEach(l => l.classList.remove("highlight"));
      if (curr >= 0 && curr < lines.length) {
        lines[curr].classList.add("highlight");
        lines[curr].scrollIntoView({ block: "center", behavior: "smooth" });
      }
    }

    document.getElementById("renderBtn").addEventListener("click", renderCode);
    document.getElementById("down").addEventListener("click", () => { if (curr < getCode().length - 1) { curr++; selectLine(); } });
    document.getElementById("up").addEventListener("click", () => { if (curr > 0) { curr--; selectLine(); } });

    const body = document.querySelector("body");
    const rightPanel = document.getElementById("right");
    const toggleBtn = document.getElementById("toggle-code");

    let codeVisible = true;
    toggleBtn.addEventListener("click", () => {
      codeVisible = !codeVisible;
      if (codeVisible) {
        rightPanel.style.display = "grid";
        body.style.gridTemplateColumns = "70% 30%";
      } else {
        rightPanel.style.display = "none";
        body.style.gridTemplateColumns = "100%";
      }
    });
  </script>
</body>

</html>