{
    "SL-Insert-Start": "void insertStart_sl(int data) {\n\tstruct node *ptr = (struct node*)malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed.\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (start == NULL) {\n\t\tstart = last = ptr;\n\t\treturn;\n\t}\n\tptr->next = start;\n\tstart = ptr;\n}",

    "SL-Insert-End": "void insertEnd_sl(int data) {\n\tstruct node *ptr = (struct node*)malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed.\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (start == NULL) {\n\t\tstart = last = ptr;\n\t\treturn;\n\t}\n\tlast->next = ptr;\n\tlast = ptr;\n}",

    "SL-Insert-Before": "void insertBefore_sl(int data, int elem) {\n\tint pos = search(elem);\n\tif (pos == -1 || pos == -2) {\n\t\tprintf(\"Operation cannot be performed.\");\n\t\treturn;\n\t}\n\tstruct node *ptr = (struct node*)malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed.\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (pos == 0) {\n\t\tptr->next = start;\n\t\tstart = ptr;\n\t\treturn;\n\t}\n\tstruct node *temp = start;\n\tfor (int i = 0; i < pos - 1; i++) {\n\t\ttemp = temp->next;\n\t}\n\tptr->next = temp->next;\n\ttemp->next = ptr;\n}",

    "SL-Insert-After": "void insertAfter_sl(int data, int elem) {\n\tint pos = search(elem);\n\tif (pos == -1 || pos == -2) {\n\t\tprintf(\"Operation cannot be performed.\");\n\t\treturn;\n\t}\n\tstruct node *ptr = (struct node*)malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed.\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (pos == count() - 1) {\n\t\tlast->next = ptr;\n\t\tlast = ptr;\n\t\treturn;\n\t}\n\tstruct node *temp = start;\n\tfor (int i = 0; i < pos; i++) {\n\t\ttemp = temp->next;\n\t}\n\tptr->next = temp->next;\n\ttemp->next = ptr;\n}",

    "SL-Insert-At": "void insertAt_sl(int data, int pos) {\n\tif (pos < 1 || pos > count() + 1) {\n\t\tprintf(\"Enter Position in Range: (1 - %d)\", count() + 1);\n\t\treturn;\n\t}\n\tstruct node *ptr = (struct node*)malloc(sizeof(struct node));\n\tif (ptr == NULL) {\n\t\tprintf(\"Memory Allocation Failed.\");\n\t\treturn;\n\t}\n\tptr->data = data;\n\tptr->next = NULL;\n\tif (pos == 1 && start == NULL) {\n\t\tstart = last = ptr;\n\t\treturn;\n\t}\n\tif (pos == 1) {\n\t\tptr->next = start;\n\t\tstart = ptr;\n\t\treturn;\n\t}\n\tif (pos == count() + 1) {\n\t\tlast->next = ptr;\n\t\tlast = ptr;\n\t\treturn;\n\t}\n\tstruct node *temp = start;\n\tfor (int i = 0; i < pos - 2; i++) {\n\t\ttemp = temp->next;\n\t}\n\tptr->next = temp->next;\n\ttemp->next = ptr;\n}",

    "SL-Delete-Start": "void deleteStart_sl() {\n\tif (start == NULL) {\n\t\tprintf(\"List is Empty.\");\n\t\treturn;\n\t}\n\tstruct node *del = start;\n\tif (start == last) {\n\t\tstart = last = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tstart = start->next;\n\tfree(del);\n}",

    "SL-Delete-End": "void deleteEnd_sl() {\n\tif (start == NULL) {\n\t\tprintf(\"List is Empty.\");\n\t\treturn;\n\t}\n\tstruct node *del = last;\n\tif (start == last) {\n\t\tstart = last = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tstruct node *temp = start;\n\twhile (temp->next != last) {\n\t\ttemp = temp->next;\n\t}\n\tlast = temp;\n\tlast->next = NULL;\n\tfree(del);\n}",

    "SL-Delete-Before": "void deleteBefore_sl(int elem) {\n\tint pos = search(elem);\n\tif (pos == -1 || pos == -2) {\n\t\tprintf(\"Operation cannot be performed.\");\n\t\treturn;\n\t}\n\tif (pos == 0) {\n\t\tprintf(\"No Value present before\");\n\t\treturn;\n\t}\n\tstruct node *del;\n\tif (pos == 1) {\n\t\tdel = start;\n\t\tstart = start->next;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tstruct node *temp = start;\n\tfor (int i = 0; i < pos - 2; i++) {\n\t\ttemp = temp->next;\n\t}\n\tdel = temp->next;\n\ttemp->next = del->next;\n\tfree(del);\n}",

    "SL-Delete-After": "void deleteAfter_sl(int elem) {\n\tint pos = search(elem);\n\tif (pos == -1 || pos == -2) {\n\t\tprintf(\"Operation cannot be performed.\");\n\t\treturn;\n\t}\n\tif (pos == count() - 1) {\n\t\tprintf(\"No Value present After\");\n\t\treturn;\n\t}\n\tstruct node *temp = start, *del;\n\tif (pos == count() - 2) {\n\t\twhile (temp->next != last) {\n\t\t\ttemp = temp->next;\n\t\t}\n\t\tdel = last;\n\t\tlast = temp;\n\t\tlast->next = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < pos; i++) {\n\t\ttemp = temp->next;\n\t}\n\tdel = temp->next;\n\ttemp->next = del->next;\n\tfree(del);\n}",

    "SL-Delete-At": "void deleteAt_sl(int pos) {\n\tif (start == NULL) {\n\t\tprintf(\"List is Empty.\");\n\t\treturn;\n\t}\n\tif (pos < 1 || pos > count()) {\n\t\tprintf(\"Enter Position in Range: (1 - %d)\", count());\n\t\treturn;\n\t}\n\tstruct node *temp = start, *del;\n\tif (pos == 1) {\n\t\tdel = start;\n\t\tstart = start->next;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tif (pos == count()) {\n\t\twhile (temp->next != last) {\n\t\t\ttemp = temp->next;\n\t\t}\n\t\tdel = last;\n\t\tlast = temp;\n\t\tlast->next = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < pos - 2; i++) {\n\t\ttemp = temp->next;\n\t}\n\tdel = temp->next;\n\ttemp->next = del->next;\n\tfree(del);\n}",

    "SL-Delete-Elem": "void deleteElem_sl(int elem) {\n\tint pos = search(elem);\n\tif (pos == -1 || pos == -2) {\n\t\tprintf(\"Operation cannot be performed.\");\n\t\treturn;\n\t}\n\tstruct node *temp = start, *del;\n\tif (pos == 0 && start == last){\n\t\tdel = start;\n\t\tstart = last = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tif (pos == 0) {\n\t\tdel = start;\n\t\tstart = start->next;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tif (pos == count() - 1) {\n\t\twhile (temp->next != last) {\n\t\t\ttemp = temp->next;\n\t\t}\n\t\tdel = last;\n\t\tlast = temp;\n\t\tlast->next = NULL;\n\t\tfree(del);\n\t\treturn;\n\t}\n\tfor (int i = 0; i < pos - 1; i++) {\n\t\ttemp = temp->next;\n\t}\n\tdel = temp->next;\n\ttemp->next = del->next;\n\tfree(del);\n}"
}
